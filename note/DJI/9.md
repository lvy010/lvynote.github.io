# 第九章：内存管理单元(MMU)

在[第八章：开放协议](08_open_protocol_.md)中，我们了解到链路器使用开放协议与无人机通信。这些==协议数据包需要存储空间==——这就是**内存管理单元(MMU)**的舞台，它是SDK内部高效管理内存的"智能管家"

## 什么是MMU？（SDK的内存调度中枢）

MMU是Onboard-SDK中专司内存动态分配与释放的核心模块，其工作原理可类比：

* **工作台**：SDK启动时预留的固定内存空间
* **MMU**：智能分配工作台区域的任务调度员
* **内存块**：被分配使用的独立工作区域

### 为什么需要MMU？

高效内存管理对无人机系统至关重要：
* **防溢出**：避免内存冲突导致数据损坏
* **动态适配**：灵活应对视频流大缓存与指令小缓存的差异需求
* **资源管控**：确保在嵌入式设备等受限环境中稳定运行

## MMU工作机制（开发者无感调用）

开发者通常**无需直接操作MMU**，SDK模块会自动调用其接口：

```cpp
// 协议模块申请内存示例
MMU_Tab* mem = mmu->allocMemory(1024);  // 申请1KB内存
//...使用内存...
mmu->freeMemory(mem);                  // 释放内存
```

## 核心实现

### 内存表初始化（`dji_memory.cpp`）

```cpp
void MMU::setupMMU() 
{
    memoryTable[0].usageFlag = 1;       // 首边界标记
    for(int i=1; i<MMU_TABLE_NUM-1; i++) 
        memoryTable[i].usageFlag = 0;   // 初始化空闲块
    memoryTable[MMU_TABLE_NUM-1].usageFlag = 1; // 尾边界标记
}
```

### 智能内存分配（`allocMemory`）

```cpp
MMU_Tab* MMU::allocMemory(uint16_t size) 
{
    if(size > MEMORY_SIZE) return NULL; // 容量检查
    for(int i=1; i<MMU_TABLE_NUM-1; i++) {
        if(memoryTable[i].usageFlag == 0) { // 发现空闲块
            memoryTable[i].pmem = calculateAddress(); // 计算物理地址
            memoryTable[i].memSize = size;
            memoryTable[i].usageFlag = 1;
            return &memoryTable[i];     // 返回分配块指针
        }
    }
    return NULL; // 无可用空间
}
```

### 内存释放（`freeMemory`）

```cpp
void MMU::freeMemory(MMU_Tab* mmu_tab) 
{
    mmu_tab->usageFlag = 0;  // 简单标记为可用
}
```

## 模块协作

开放协议模块使用MMU管理会话缓存：

```cpp
// 分配会话缓存
CMDSession* OpenProtocol::allocSession() 
{
    MMU_Tab* mem = mmu->allocMemory(SESSION_SIZE);
    session->mmu = mem;  // 关联内存块
    return session;
}

// 释放会话缓存
void OpenProtocol::freeSession() 
{
    mmu->freeMemory(session->mmu);
}
```

## 结论

==MMU如同SDK的"内存交通指挥"，通过预分配池和智能调度机制==，确保：

1. 协议数据包安全存储
2. 临时缓冲区高效复用
3. 系统内存资源可控

其精妙设计使开发者无需关注底层内存管理，专注业务逻辑开发

（关于 内存池这部分，em之前仿写过一个高并发内存池的轮子，之后想到了窝给它翻出来整理一下也写成博客😋）

---
[下一章：平台抽象层(PAL)](10_platform_abstraction_layer__pal__.md)

