# 第6章：AirsimROSWrapper

在[前一章](05_geometriccontroller_.md)中，我们看到了`GeometricController`如何将高级飞行计划转化为精确的电机命令。但这些令人惊叹的规划与控制系统都存在于无人机的软件“大脑”中。为了实际飞行，这个==“大脑”需要连接到*物理世界*==——或者在我们的案例中，连接到它的现实仿真环境。

## AirsimROSWrapper解决了什么问题？

假设我们的智能无人机，配备了`AvoidanceStateMachine`（第1章）、`HighLvlMpc`规划器（第3章）和`GeometricController`（第5章），已经准备好应对复杂环境。与其直接飞行一台昂贵且真实的无人机，我们更希望在计算机仿真中安全地测试其智能性。

我们使用**AirSim**（基于Unreal Engine的强大仿真器）来创建详细的3D世界。另一方面，无人机的“大脑”使用**ROS（机器人操作系统）**在其不同软件模块之间进行通信。这两个系统——AirSim和ROS——使用完全不同的“语言”。AirSim有自己的方式描述无人机状态和接收命令，而ROS使用其标准化的消息和话题。

问题是：**如何让我们基于ROS的无人机软件与AirSim仿真器对话？**如何将仿真相机图像和传感器数据*从*AirSim*传递到*ROS，以及如何将ROS控制命令*发送到*AirSim中的无人机？

这正是**`AirsimROSWrapper`**的工作！可以将其视为一个**通用翻译器**或**智能桥梁**。它是将运行在ROS中的`Avoid-MPC`系统连接到AirSim仿真器逼真3D世界的关键组件。它让我们能够在虚拟环境中测试无人机的智能性，就像在真实无人机上飞行一样。

## 关键概念

`AirsimROSWrapper`通过理解AirSim的内部语言和ROS的通信系统来运作。

1.  **AirSim（仿真世界）：**
    *   这是无人机“飞行”的虚拟环境。它提供逼真的图形、物理和传感器仿真（如相机、IMU、GPS）。
    *   它有自己的方式输出信息（例如包含位置、速度等的`MultirotorState`对象）和接收命令（例如`moveByVelocityAsync`函数调用）。

2.  **ROS（无人机的“大脑”系统）：**
    *   这是所有无人机软件模块（如`AvoidanceStateMachine`、`HighLvlMpc`、`GeometricController`）运行并通过**ROS消息**和**ROS话题**（如`/odom`用于里程计、`/imu`用于IMU数据、`/airsim_node/drone_1/front_center/DepthPlanar`用于深度图像）进行通信的框架。

3.  **AirsimROSWrapper（翻译器/桥梁）：**
    *   这是一个特殊的ROS节点（运行中的程序），位于AirSim和其他ROS节点之间。
    *   它的主要功能是**翻译**：
        *   **AirSim数据到ROS消息：** 它从AirSim中提取传感器数据（图像、IMU、里程计）并将其转换为标准ROS消息，然后发布到ROS话题。
        *   **ROS命令到AirSim动作：** 它订阅ROS命令话题，接收消息并将其翻译为AirSim理解的特定API调用，发送给仿真无人机。

## AirsimROSWrapper如何连接一切

假设我们的`AvoidanceStateMachine`处于`TASK`状态，在AirSim仿真器中飞行：

1.  **传感器数据流（AirSim到ROS）：**
    *   AirSim中的仿真无人机不断“飞行”，其虚拟传感器收集数据（如深度相机图像、位置和加速度）。
    *   `AirsimROSWrapper`定期*询问*AirSim获取这些数据。
    *   然后，它将AirSim的数据格式（例如相机数据的`ImageResponse`对象、无人机状态的`MultirotorState`）转换为标准ROS消息（例如`sensor_msgs::Image`、`nav_msgs::Odometry`、`sensor_msgs::Imu`）。
    *   最后，它将这些ROS消息**发布**到特定的ROS话题（例如`/mavros/local/odom`、`/mavros/imu/data`、`/airsim_node/drone_1/front_center/DepthPlanar`）。
    *   我们的`AvoidanceStateMachine`（以及`FrameKDMap`等组件）**订阅**这些话题，接收仿真传感器数据，就像来自真实无人机一样。

2.  **控制命令流（ROS到AirSim）：**
    *   我们的`AvoidanceStateMachine`（通过`GeometricController`）计算期望的控制命令（例如期望角速度和推力）。
    *   它将这些命令作为ROS消息**发布**到特定话题（例如`/mavros/setpoint_raw/attitude`）。
    *   `AirsimROSWrapper`**订阅**这一ROS命令话题。
    *   它接收ROS命令消息并将其翻译为AirSim API调用（例如`moveByAngleRatesThrottleAsync`）。
    *   这一API调用被发送到AirSim，使仿真无人机按命令移动。

以下是`AirsimROSWrapper`作为桥梁的简化示意图：

````artifact
id: flow-chat-example
name: AirsimROSWrapper工作流程
type: mermaid
content: |-
  sequenceDiagram
      participant AirSim as AirSim Simulator
      participant ARW as AirsimROSWrapper
      participant ROS as ROS Topics
      participant ASM as AvoidanceStateMachine

      Note over AirSim: Drone flies in 3D environment
      AirSim->>ARW: Sends raw sensor data (e.g. camera image, drone state)
      ARW->>ROS: Publishes ROS messages (e.g. /odom, /imu, /depth_image)
      ROS->>ASM: Delivers sensor messages
      ASM->>ASM: Processes data, plans, calculates commands
      ASM->>ROS: Publishes ROS control message (e.g. /mavros/setpoint_raw/attitude)
      ROS->>ARW: Delivers control message
      ARW->>AirSim: Sends AirSim API call (e.g. moveByVelocityAsync)
      Note over AirSim: Simulated drone executes command
````

## 深入代码（简化版）

让我们看看`AirsimROSWrapper`是如何设置和处理这一翻译的。主要代码位于`airsim_ros_pkgs`包中。

### 1. `AirsimROSWrapper`类结构（`airsim_ros_wrapper.h`）

这是管理连接的主类。它持有对AirSim客户端（与AirSim通信的方式）和各种ROS发布者与订阅者的引用。

```cpp
// From: roswrapper/ros/src/airsim_ros_pkgs/include/airsim_ros_wrapper.h
#include "ros/ros.h"
#include "vehicles/multirotor/api/MultirotorRpcLibClient.hpp" // AirSim client

class AirsimROSWrapper {
public:
    // Constructor: Sets up ROS node handles and connects to AirSim.
    AirsimROSWrapper(const ros::NodeHandle &nh,
                     const ros::NodeHandle &nh_private,
                     const std::string &host_ip);

private:
    // A nested class representing a single drone in ROS.
    // It holds its specific publishers and subscribers.
    class MultiRotorROS : public VehicleROS {
    public:
        msr::airlib::MultirotorState curr_drone_state; // Data from AirSim
        ros::Subscriber vel_cmd_body_frame_sub; // ROS sub for velocity commands
        ros::Subscriber pose_cmd_body_frame_sub; // ROS sub for pose commands
        ros::ServiceServer takeoff_srvr; // ROS service for takeoff
        ros::ServiceServer land_srvr;    // ROS service for land
    };

    // The main AirSim client to communicate with the simulator.
    std::unique_ptr<msr::airlib::RpcLibClientBase> airsim_client_ = nullptr;
    // A specialized client for getting drone states efficiently.
    msr::airlib::MultirotorRpcLibClient airsim_client_states_;

    // A map to store information for multiple drones, looked up by name.
    std::unordered_map<std::string, std::unique_ptr<VehicleROS>>
        vehicle_name_ptr_map_;

    // ROS Publishers for crucial IMU and Odometry data for our drone.
    ros::Publisher mPubMavrosImuCmd;  // Publishes to /mavros/imu/data
    ros::Publisher mPubLocalOdomCmd;  // Publishes to /mavros/local/odom

    // ROS Timers to periodically fetch data from AirSim.
    ros::Timer airsim_img_response_RGBD_timer_; // For camera images
    ros::Timer airsim_control_update_timer_;    // For drone state updates

    // ROS Callback Queues for asynchronous (parallel) processing.
    ros::CallbackQueue img_timer_cb_queue_RGBD_;
    ros::CallbackQueue drone_state_timer_cb_queue_;
    ros::CallbackQueue command_listener_queue_;

    std::string mavrosVechileName; // The name of the drone we are controlling.
    // ... other internal variables and flags ...
};
```
`AirsimROSWrapper`类非常庞大，因为它处理*所有*类型的车辆（无人机、汽车）和*所有*类型的传感器（相机、IMU、GPS、激光雷达）的仿真。对于`Avoid-MPC`，我们主要关注`MultiRotorROS`类（用于无人机）及其状态/传感器数据和控制命令。它使用多个AirSim客户端（`airsim_client_`、`airsim_client_states_`）高效地获取不同类型的数据。重要的是，`mPubMavrosImuCmd`和`mPubLocalOdomCmd`用于发布关键的IMU和里程计数据，这些数据是我们的`AvoidanceStateMachine`（第1章）所依赖的。

### 2. 初始化Wrapper（`airsim_ros_wrapper.cpp`）

当`airsim_node`（`AirsimROSWrapper`的可执行文件）启动时，Wrapper的构造函数和`initialize_ros()`函数会设置一切，包括连接到AirSim和建立ROS通信。

```cpp
// From: roswrapper/ros/src/airsim_ros_pkgs/src/airsim_ros_wrapper.cpp
AirsimROSWrapper::AirsimROSWrapper(const ros::NodeHandle &nh,
                                   const ros::NodeHandle &nh_private,
                                   const std::string &host_ip)
    // Initialize ROS async spinners for parallel processing of different data types.
    : img_RGBD_async_spinner_(1, &img_timer_cb_queue_RGBD_),
      drone_state_async_spinner_(1, &drone_state_timer_cb_queue_),
      command_listener_async_spinner_(1, &command_listener_queue_),
      nh_(nh), nh_private_(nh_private), host_ip_(host_ip),
      // Initialize AirSim clients for different data streams.
      airsim_client_images_(host_ip), airsim_client_states_(host_ip)
{
    initialize_ros(); // Call the setup function for ROS.
    std::cout << "AirsimROSWrapper Initialized!\n";
}

void AirsimROSWrapper::initialize_ros() {
    // Read parameters from the ROS launch file.
    nh_private_.getParam("vechile_name", mavrosVechileName); // Get drone's name.

    create_ros_pubs_from_settings_json(); // Create publishers/subscribers based on AirSim settings.

    // Set up a ROS timer to periodically fetch drone state from AirSim.
    ros::TimerOptions timer_options_control_update_(
        ros::Duration(0.01), // Update every 0.01 seconds (100 Hz).
        boost::bind(&AirsimROSWrapper::drone_state_timer_cb, this, _1),
        &drone_state_timer_cb_queue_);
    airsim_control_update_timer_ =
        nh_private_.createTimer(timer_options_control_update_);

    // Explicitly set up publishers for /mavros IMU and Odometry topics.
    mPubMavrosImuCmd =
        nh_private_.advertise<sensor_msgs::Imu>("/mavros/imu/data", 50);
    mPubLocalOdomCmd =
        nh_private_.advertise<nav_msgs::Odometry>("/mavros/local/odom", 50);

    initialize_airsim(); // Connect to the AirSim simulator.
}
```
构造函数初始化Wrapper，包括其专用的`ros::AsyncSpinner`用于并发处理不同类型的回调（例如图像、无人机状态、命令）。`initialize_ros()`读取ROS参数（例如从`airsim_node.launch`中获取`vechile_name`），然后调用`create_ros_pubs_from_settings_json()`动态创建ROS通信通道，用于AirSim的`settings.json`文件中指定的*所有*无人机和传感器。重要的是，它设置了定时器（如`airsim_control_update_timer_`）以定期获取无人机状态，并直接创建了`/mavros/imu/data`和`/mavros/local/odom`的发布者。最后，`initialize_airsim()`建立与AirSim仿真器的实际连接。

### 3. 获取并发布无人机状态（`drone_state_timer_cb`在`airsim_ros_wrapper.cpp`中）

此函数由ROS定时器重复调用，以更新无人机的状态和传感器数据。

```cpp
// From: roswrapper/ros/src/airsim_ros_pkgs/src/airsim_ros_wrapper.cpp
void AirsimROSWrapper::drone_state_timer_cb(const ros::TimerEvent &event) {
    try {
        const auto now = update_state(); // 1. Get current state from AirSim.
        // ... (ROS clock publishing logic) ...
        publish_vehicle_state(); // 2. Publish state to ROS topics.
    } catch (rpc::rpc_error &e) {
        ROS_ERROR("Exception in drone_state_timer_cb: %s", e.what());
    }
}

// Internal helper to fetch state from AirSim for all vehicles.
ros::Time AirsimROSWrapper::update_state() {
    ros::Time curr_ros_time = ros::Time::now(); // Default timestamp.
    for (auto &vehicle_name_ptr_pair : vehicle_name_ptr_map_) {
        // Only process the drone we are configured to control.
        auto &vehicle_ros = vehicle_name_ptr_pair.second;
        auto drone = static_cast<MultiRotorROS *>(vehicle_ros.get());

        // Get the drone's latest state from AirSim.
        drone->curr_drone_state = airsim_client_states_.getMultirotorState(
            vehicle_ros->vehicle_name);
        // Convert AirSim timestamp to ROS time.
        curr_ros_time = airsim_timestamp_to_ros(drone->curr_drone_state.timestamp);

        // Convert the AirSim state into a ROS Odometry message.
        vehicle_ros->curr_odom = get_odom_msg_from_multirotor_state(drone->curr_drone_state);
        // Set ROS message header information.
        vehicle_ros->curr_odom.header.frame_id = vehicle_ros->vehicle_name;
        vehicle_ros->curr_odom.child_frame_id = vehicle_ros->odom_frame_id;
        vehicle_ros->curr_odom.header.stamp = curr_ros_time;
    }
    return curr_ros_time;
}
```
`drone_state_timer_cb`是状态更新的核心。它调用`update_state()`从AirSim获取每个配置无人机的`MultirotorState`。这一AirSim数据（`drone->curr_drone_state`）随后被转换为`nav_msgs::Odometry`消息并存储在`vehicle_ros->curr_odom`中。更新状态后，调用`publish_vehicle_state()`。

### 4. 发布传感器数据到ROS（`publish_vehicle_state`在`airsim_ros_wrapper.cpp`中）

此函数获取最新的AirSim数据，将其转换为ROS消息并发布。

```cpp
// From: roswrapper/ros/src/airsim_ros_pkgs/src/airsim_ros_wrapper.cpp
void AirsimROSWrapper::publish_vehicle_state() {
    for (auto &vehicle_name_ptr_pair : vehicle_name_ptr_map_) {
        auto &vehicle_ros = vehicle_name_ptr_pair.second;

        // Ensure we only publish for the main drone.
        if (vehicle_ros->vehicle_name != mavrosVechileName) {
            continue;
        }

        // Create a new Odometry message for publication to /mavros/local/odom.
        nav_msgs::Odometry msgPub;
        msgPub.header = vehicle_ros->curr_odom.header;
        // Apply coordinate transformations (e.g., invert Y and Z for position, orientation, velocity)
        // This converts from AirSim's NED to a ROS-compatible frame (often ENU).
        msgPub.pose.pose.orientation.y = -vehicle_ros->curr_odom.pose.pose.orientation.y;
        msgPub.pose.pose.orientation.z = -vehicle_ros->curr_odom.pose.pose.orientation.z;
        msgPub.pose.pose.position.y = -vehicle_ros->curr_odom.pose.pose.position.y;
        msgPub.pose.pose.position.z = -vehicle_ros->curr_odom.pose.pose.position.z;
        msgPub.twist.twist.angular.y = -vehicle_ros->curr_odom.twist.twist.angular.y;
        msgPub.twist.twist.angular.z = -vehicle_ros->curr_odom.twist.twist.angular.z;
        msgPub.twist.twist.linear.y = -vehicle_ros->curr_odom.twist.twist.linear.y;
        msgPub.twist.twist.linear.z = -vehicle_ros->curr_odom.twist.twist.linear.z;
        mPubLocalOdomCmd.publish(msgPub); // Publish the transformed odometry.

        // Iterate through other configured sensors.
        for (auto &sensor_publisher : vehicle_ros->sensor_pubs) {
            if (sensor_publisher.sensor_type == SensorBase::SensorType::Imu) {
                // Get IMU data from AirSim.
                auto imu_data = airsim_client_states_.getImuData(
                    sensor_publisher.sensor_name, vehicle_ros->vehicle_name);
                sensor_msgs::Imu imu_msg = get_imu_msg_from_airsim(imu_data);
                imu_msg.header.frame_id = vehicle_ros->vehicle_name;
                // Apply coordinate transformations for IMU data.
                imu_msg.angular_velocity.y *= -1.;
                imu_msg.angular_velocity.z *= -1.;
                imu_msg.linear_acceleration.y *= -1.;
                imu_msg.linear_acceleration.z *= -1.;
                imu_msg.orientation.y *= -1.;
                imu_msg.orientation.z *= -1.;
                mPubMavrosImuCmd.publish(imu_msg); // Publish the transformed IMU data.
                break; // Assuming only one IMU for simplicity in this loop.
            }
        }
    }
}
```
此函数在`update_state()`之后调用。它遍历配置的车辆，对于主无人机（由`mavrosVechileName`标识），它获取`curr_odom`（包含转换后的AirSim状态）并将其发布到`/mavros/local/odom`。它还从AirSim获取`ImuData`，使用`get_imu_msg_from_airsim()`进行转换，应用必要的坐标系转换（通常反转Y和Z轴以从AirSim的NED坐标系转换为ROS的ENU或类似约定），并发布到`/mavros/imu/data`。这些是`AvoidanceStateMachine`