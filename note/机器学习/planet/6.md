# 第6章：配置系统(AttrDict)

在[前一章](05_planning_algorithm__cross_entropy_method___cem__.md)中，我们探讨了**规划算法(交叉熵方法-CEM)**如何帮助`MPCAgent`通过`潜在动态模型`模拟未来以选择最佳动作。你可能注意到CEM本身有许多参数，如`amount`（采样计划数量）、`iterations`（优化迭代次数）和`horizon`（规划步长）。

从[训练器](01_trainer__and_experiment__.md)、[MPCAgent](02_mpcagent__model_predictive_control_agent__.md)、[潜在动态模型](04_latent_dynamics_model__cell__.md)到规划算法，整个系统包含**数百个**配置项。这些被称为==**超参数**的设置控制着神经网络规模、数据收集频率等方方面面==。

管理这些配置可能很快变得混乱不堪：如何确保使用正确的值？如何复现上周成功的实验？这正是PlaNet中**配置系统(AttrDict)**的用武之地

---

## 核心价值：结构化配置管理

假设我们训练虚拟机器人行走，需要配置：
- **训练器参数**：总训练步数、检查点保存频率
- **模型参数**：神经网络尺寸、潜在动态模型类型（`RSSM`或`DRNN`）
- **环境参数**：动作重复次数

若分散定义这些参数，代码将难以维护和复现。`AttrDict`通过以下特性解决这些问题：

### 1. ==结构化存储==
```python
config = AttrDict()
config.trainer = AttrDict(steps=1e6, log_every=1e3)
config.model = AttrDict(type='rssm', state_size=30)
```

### 2. ==安全访问==
```python
# 点号访问更直观
lr = config.learning_rate  # 优于 config['learning_rate']

# 防错机制
try:
    print(config.non_exist_key)  # 触发AttributeError而非静默失败
except AttributeError:
    pass
```

### 3. ==修改控制==
```python
config.lock()  # 锁定配置

with config.unlocked:  # 安全修改区间
    config.new_param = 'value'  # 允许修改
```

### 4. ==持久化支持==
```python
config.save('exp_config.yaml')  # YAML格式保存
loaded_config = AttrDict.load('exp_config.yaml')  # 精确复现实验
```

---

## 技术实现

### 核心机制
`AttrDict`继承自Python字典，通过重写`__getattr__`和`__setattr__`实现点号访问：

```python
class AttrDict(dict):
    def __getattr__(self, name):
        try:
            return self[name]  # 将config.key转为config['key']
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        if not self._unlocked:  # 锁定检查
            raise RuntimeError("Config is locked!")
        self[name] = value
```

### 嵌套结构处理
递归处理嵌套字典的自动转换：
```python
nested_config = AttrDict()
nested_config.sub = {'key': 'value'}  # 自动将普通dict转为AttrDict
assert isinstance(nested_config.sub, AttrDict)  # True
```

---

## 工程实践指南

### 1. 实验配置模板
```python
def default_config():
    config = AttrDict(_unlocked=True)
    # 训练参数
    config.trainer = AttrDict(
        steps=1e6,
        batch_size=50
    )
    # 模型参数  
    config.model = AttrDict(
        type='rssm',
        hidden_size=200
    )
    return config
```

### 2. 命令行参数集成
```python
def merge_cli_args(config, args):
    with config.unlocked:
        for key, val in args.items():
            keys = key.split('.')  # 支持点号路径：trainer.steps
            target = config
            for k in keys[:-1]:
                target = target[k]
            target[keys[-1]] = val
```

### 3. 实验复现流程
```python
# 首次运行
config = default_config()
config.save('config.yaml')

# 后续复现
loaded_config = AttrDict.load('config.yaml')
assert loaded_config == config  # 确保配置完全一致
```

---

## 对比：AttrDict vs 原生字典

| 特性         | 原生字典                   | AttrDict                 |
| ------------ | -------------------------- | ------------------------ |
| **访问语法** | `config['key']`            | `config.key`             |
| **错误处理** | 静默返回`None`或`KeyError` | 明确抛出`AttributeError` |
| **修改安全** | 任意位置可修改             | 支持锁定机制             |
| **嵌套支持** | 需手动处理                 | 自动递归转换             |
| **持久化**   | 需额外序列化逻辑           | 内置YAML支持             |

---

## 总结

`AttrDict`通过：
1. **统一入口**：集中管理所有实验参数
2. **安全访问**：点号语法与严格错误检查
3. **修改管控**：锁定机制防止意外更改
4. **完美复现**：YAML序列化保障实验可重复性

这种配置管理模式已成为PlaNet架构的重要基石。本教程至此已完整解析PlaNet的所有核心组件，现在可以自信地探索代码并开展自己的实验了

END *★,°*:.☆(￣▽￣)/.°★* 。