

# 第6章：格式化字符串编译（`FMT_COMPILE`，`compiled_string`）

在[上一章：输出缓冲（`basic_memory_buffer`，`basic_appender`）](05_output_buffering___basic_memory_buffer____basic_appender___.md)中，我们看到了`fmt`如何在将格式化文本发送到最终目的地之前==高效地收集和存储==它。

这对于许多场景来说是一个很好的优化。但如果我们需要**反复格式化完全相同的消息模板**，比如成千上万次甚至数百万次，有没有办法让它更快呢？

想象一下，我们经营一家繁忙的餐厅，需要全天反复准备同一道热门菜品（“特色意大利面配{sauce}和{topping}”）。如果每次订单到来时，厨师都需要阅读整个食谱、收集食材并弄清楚烹饪步骤，那会非常慢。

但如果厨师在一天开始时**预先烹饪**酱汁、**预先切好**配料，并记住**那道特定菜品**的精确步骤呢？现在，当订单到来时，他们只需==抓取预先准备好的食材==，执行已知的步骤，然后上菜。这样快多了（预制菜思想bush）

这种“预先准备”正是**格式化字符串编译**（使用`FMT_COMPILE`和`compiled_string`）在`fmt`库中实现的功能。它==不是在每次==运行时解析格式字符串（我们的消息模板），而是在==**编译时**一次性处理==它，生成高度优化的代码或数据结构，使得重复的格式化操作变得极其高效。

## 概念：`FMT_COMPILE`和`compiled_string`

可以将这两个组件理解为：

1. **`FMT_COMPILE`**：这就像是食谱上的**“预烹饪按钮”**。我们用这个宏包装格式字符串字面量（例如`FMT_COMPILE("Hello, {}!")`），它会告诉C++编译器：“嘿，现在就在编译时分析这个格式字符串，并生成最高效的‘食谱’。”

2. **`compiled_string`**：这是**“预先烹饪的食谱”**或“专用打印机器”。它是`fmt`在编译时创建的格式字符串的内部优化表示，包含了所有指令（例如“复制‘Hello, ’”、“将第一个参数格式化为字符串”、“然后复制‘!’”），这些指令可以比运行时从头解析字符串快得多地执行。

通过使用`FMT_COMPILE`，我们将潜在昂贵的格式字符串解析步骤从运行时移到了编译时，从而显著提升了重复格式化任务的性能。

## 如何使用`FMT_COMPILE`

最棒的是，使用`FMT_COMPILE`非常简单，且不会改变基本的格式化调用。我们只需包装格式字符串字面量。

来看一个常见场景：

```cpp
#include <fmt/format.h> // 用于fmt::print
#include <fmt/compile.h> // 用于FMT_COMPILE
#include <string>

int main() {
    std::string user_name = "Alice";
    int user_score = 1500;

    // 常规运行时格式化：
    fmt::print("用户: {}, 分数: {}\n", user_name, user_score);

    // 使用编译时格式字符串：
    fmt::print(FMT_COMPILE("用户: {}, 分数: {}\n"), user_name, user_score);
//这种写法会多用一点~
    
    // 如果使用C++20，还可以用更简洁的用户定义字面量：
    using namespace fmt::literals;
    fmt::print("用户: {}, 分数: {}"_cf, user_name, user_score);

    // 另一个编译时工具：编译时字符串生成！
    // 这会在编译时生成字符串字面量"Hello, World!"。
    constexpr auto static_message = FMT_STATIC_FORMAT("Hello, {}!", "World");
    fmt::println("静态消息: {}", static_message.str());
    // static_message.str()的输出是"Hello, World!"
    return 0;
}
```

**输出：**
```
用户: Alice, 分数: 1500
用户: Alice, 分数: 1500
用户: Alice, 分数: 1500
静态消息: Hello, World!
```

**解释：**

- 注意输出是完全相同的！==`FMT_COMPILE`不会改变**打印的内容**，只会改变`fmt`准备打印的方式==。
- `FMT_COMPILE`宏（或`_cf`字面量）将字符串字面量（`"用户: {}, 分数: {}\n"`）传递给`fmt`内部的特殊编译时函数。这些函数分析字符串，确定参数的位置及其默认格式化规则。
- 这种分析会创建`compiled_string`对象，随后被`fmt::print`函数使用。下次使用**相同的`compiled_string`**调用`fmt::print`时，所有解析工作已经完成，从而更快地执行。
- `FMT_STATIC_FORMAT`是一个更高级的编译时功能，如果所有输入都是`constexpr`，它会在编译时生成**整个格式化字符串**作为`constexpr`静态数组。这对于==固定消息==非常有用。

通常，当我们在编译时知道格式字符串并且程序中频繁使用时，会使用`FMT_COMPILE`。

## 底层机制：编译时的魔法

让我们深入探讨`FMT_COMPILE`如何实现这种优化。

### 流程：编译时与运行时

以下是常规运行时解析和编译时解析的简化对比：

```mermaid
sequenceDiagram
    participant YourCode["我们的C++代码"]
    participant Compiler
    participant FmtRuntimeParsing["fmt::format (运行时)"]
    participant FmtCompileTimeParsing["FMT_COMPILE (编译时)"]
    participant FmtCompiledString["fmt::detail::field / text (优化代码)"]
    participant OutputBuffer["输出缓冲区"]

    YourCode->>Compiler: 编译源代码
    activate Compiler
    Compiler->>FmtCompileTimeParsing: 看到FMT_COMPILE("...")
    activate FmtCompileTimeParsing
    Note over FmtCompileTimeParsing: 一次性解析格式字符串语法
    Note over FmtCompileTimeParsing: 生成内部数据结构/专用代码（FmtCompiledString）
    FmtCompileTimeParsing-->>Compiler: 返回compiled_string对象
    deactivate FmtCompileTimeParsing
    Compiler->>YourCode: 生成包含compiled_string的可执行文件
    deactivate Compiler

    loop 使用compiled_string重复调用fmt::print
        YourCode->>FmtCompiledString: 调用fmt::print(compiled_string, args)
        activate FmtCompiledString
        Note over FmtCompiledString: 直接执行预先分析的格式化逻辑
        FmtCompiledString->>OutputBuffer: 写入格式化文本
        deactivate FmtCompiledString
    end

    loop 不使用compiled_string重复调用fmt::print
        YourCode->>FmtRuntimeParsing: 调用fmt::print("...", args)
        activate FmtRuntimeParsing
        Note over FmtRuntimeParsing: 每次解析格式字符串（第3章）
        Note over FmtRuntimeParsing: 然后应用格式化逻辑
        FmtRuntimeParsing->>OutputBuffer: 写入格式化文本
        deactivate FmtRuntimeParsing
    end
```

**关键区别：**

| 特性           | 运行时解析（常规`fmt::format`）                            | 编译时解析（`FMT_COMPILE`）                                  |
| :------------- | :--------------------------------------------------------- | :----------------------------------------------------------- |
| **解析时机**   | 每次调用格式化函数时解析。                                 | 仅在程序编译时解析一次。                                     |
| **开销**       | 每次调用都有解析开销。                                     | 运行时解析开销为零。                                         |
| **输出**       | 动态生成格式化文本。                                       | 执行预先生成的高度优化的格式化代码。                         |
| **灵活性**     | 可以处理运行时确定的格式字符串（例如用户输入或配置文件）。 | 要求格式字符串在编译时已知（字符串字面量）。                 |
| **性能**       | 适用于一次性或可变格式字符串。                             | 适用于频繁重复的固定格式字符串。                             |
| **二进制大小** | 对于多样化的格式字符串，二进制文件通常较小。               | 对于许多唯一的`FMT_COMPILE`字符串，可能会因生成的代码而增加二进制大小。 |

### 探讨：代码生成

`FMT_COMPILE`宏（定义在`include/fmt/compile.h`中）通常使用C++17的`if constexpr`和C++20的`consteval`功能（如果可用）实现。它在编译时获取字符串字面量，并将其分解为一系列高效的“格式化操作”。

从`include/fmt/compile.h`和`include/fmt/format.h`中，我们来看`FMT_COMPILE`的核心思想。

`FMT_COMPILE`宏包装字符串字面量，并通过模板将其转换为表示已解析格式字符串的对象。

```cpp
// 简化自include/fmt/compile.h
#if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)
#  define FMT_COMPILE(s) FMT_STRING_IMPL(s, fmt::compiled_string)
// ...
#endif

// 简化自include/fmt/format.h
#define FMT_STRING_IMPL(s, base)                                           \
    [] {                                                                     \
      struct FMT_VISIBILITY("hidden") FMT_COMPILE_STRING : base {            \
        using char_type = fmt::remove_cvref_t<decltype(s[0])>;               \
        constexpr explicit operator fmt::basic_string_view<char_type>()      \
            const {                                                          \
          return fmt::detail::compile_string_to_view<char_type>(s);          \
        }                                                                    \
      };                                                                     \
      /* ... 编译时检查和类型推导 ... */                     \
      return FMT_COMPILE_STRING();                                           \
    }()
```

这个复杂的宏实际上创建了一个派生自`fmt::compiled_string`的匿名`struct`。该`struct`包含一个`constexpr`转换运算符，用于将原始字符串字面量转换为`fmt::basic_string_view`。真正的魔法在于`fmt`如何在`format`重载中使用这个`compiled_string`类型。

在`include/fmt/compile.h`的`fmt::detail`中，有`text`、`field`、`spec_field`和`concat`等模板结构体。这些是实际的“编译指令”：

- **`text<Char>`**：表示格式字符串中的字面文本块。它只是将字符复制到输出。
  ```cpp
  // 简化自include/fmt/compile.h
  template <typename Char> struct text {
    basic_string_view<Char> data;
    template <typename OutputIt, typename... T>
    constexpr auto format(OutputIt out, const T&...) const -> OutputIt {
      return write<Char>(out, data); // 直接写入存储的文本
    }
  };
  ```
- **`field<Char, V, N>`**：表示简单替换字段（`{}`），==用于第N个类型为`V`的参数==。它==直接访问参数==并调用适当的`write`函数。
  ```cpp
  // 简化自include/fmt/compile.h
  template <typename Char, typename V, int N> struct field {
    template <typename OutputIt, typename... T>
    constexpr auto format(OutputIt out, const T&... args) const -> OutputIt {
      const V& arg = get_arg_checked<V, N>(args...); // 获取第N个参数
      // 根据参数类型调用简单的`write`函数，无需解析
      return write<Char>(out, arg);
    }
  };
  ```
- **`spec_field<Char, V, N>`**：类似于`field`，但用于带有格式说明符的参数（`{:s}`）。它保存一个预解析的`formatter<V, Char>`对象，知道如何应用这些说明符。
  ```cpp
  // 简化自include/fmt/compile.h
  template <typename Char, typename V, int N> struct spec_field {
    formatter<V, Char> fmt; // 类型V的预解析格式化器
    template <typename OutputIt, typename... T>
    constexpr FMT_INLINE auto format(OutputIt out, const T&... args) const
        -> OutputIt {
      const auto& vargs = fmt::make_format_args<basic_format_context<OutputIt, Char>>(args...);
      basic_format_context<OutputIt, Char> ctx(out, vargs);
      // 使用存储的格式化器格式化第N个参数
      return fmt.format(get_arg_checked<V, N>(args...), ctx);
    }
  };
  ```
- **`concat<L, R>`**：==组合两个编译后的格式部分。为整个格式字符串构建完整的“指令列表”==。
  
  ```cpp
  // 简化自include/fmt/compile.h
  template <typename L, typename R> struct concat {
    L lhs; // 第一部分
    R rhs; // 第二部分
      
    template <typename OutputIt, typename... T>
    constexpr auto format(OutputIt out, const T&... args) const -> OutputIt {
      out = lhs.format(out, args...); // 格式化第一部分
      return rhs.format(out, args...); // 然后格式化第二部分
    }
  };
  ```

当我们使用`FMT_COMPILE`时，编译器实际上构建了一个嵌套的`text`、`field`、`spec_field`和`concat`对象链。这个顶级`concat`对象（代表整个格式字符串）的`format`方法在运行时被调用。由于每个`format`方法直接知道**该做什么**（复制文本、用预配置的说明符格式化第N个参数），它避免了所有运行时解析，从而变得非常快。

这一过程消除了运行时对`parse_context`和`format_handler`（来自[第3章：格式字符串解析器（`parse_context`，`format_handler`）](03_format_string_parser___parse_context____format_handler___.md)）的需求，因为所有解析工作已经在编译时完成。

## 结论

在这最后一章中，我们探讨了`fmt`最先进的优化技术：格式化字符串编译。我们学到了：

- **`FMT_COMPILE`**（和`_cf`字面量）让我们在编译时预处理格式字符串字面量。
- 这会创建一个优化的**`compiled_string`**表示，其中包含直接的格式化指令。
- 结果是**运行时格式化显著更快**，因为昂贵的解析步骤被完全绕过。
- 在底层，`fmt`生成了专门的C++类型（`text`、`field`、`spec_field`、`concat`），封装了格式化逻辑，直接调用而不是每次解释格式字符串。

虽然它是性能关键场景中固定格式字符串的强大工具，但对于动态格式字符串或编译时开销较大的情况，常规运行时格式化仍然是很好的选择。

至此，我们已经深入了解了`fmt`的核心组件，从如何接收输入和交付输出，到如何处理参数、解析格式字符串、将类型转换为文本以及高效管理输出。现在，我们应该对`fmt`如何实现其著名的高速、安全性和灵活性有了理解~

END *★,°*:.☆(￣▽￣)/*.°★* 。

